import pygame
import numpy as np
import math

def clamp(self, x, min_val, max_val):
    return max(min(x, max_val), min_val)

class FlipFluid:
    def __init__(self, density, width, height, spacing, particle_radius, max_particles):
        # Fluid
        self.density = density
        self.f_num_x = math.floor(width / spacing) + 1
        self.f_num_y = math.floor(height / spacing) + 1
        self.h = max(width / self.f_num_x, height / self.f_num_y)
        self.f_inv_spacing = 1.0 / self.h
        self.f_num_cells = self.f_num_x * self.f_num_y

        self.u = np.zeros(self.f_num_cells, dtype=np.float32)
        self.v = np.zeros(self.f_num_cells, dtype=np.float32)
        self.du = np.zeros(self.f_num_cells, dtype=np.float32)
        self.dv = np.zeros(self.f_num_cells, dtype=np.float32)
        self.prev_u = np.zeros(self.f_num_cells, dtype=np.float32)
        self.prev_v = np.zeros(self.f_num_cells, dtype=np.float32)
        self.p = np.zeros(self.f_num_cells, dtype=np.float32)
        self.s = np.zeros(self.f_num_cells, dtype=np.float32)
        self.cell_type = np.zeros(self.f_num_cells, dtype=np.int32)
        self.cell_color = np.zeros(3 * self.f_num_cells, dtype=np.float32)

        # Particles
        self.max_particles = max_particles
        self.particle_pos = np.zeros(2 * self.max_particles, dtype=np.float32)
        self.particle_color = np.zeros(3 * self.max_particles, dtype=np.float32)
        self.particle_vel = np.zeros(2 * self.max_particles, dtype=np.float32)
        self.particle_density = np.zeros(self.f_num_cells, dtype=np.float32)
        self.particle_rest_density = 0.0
        self.particle_radius = particle_radius
        self.p_inv_spacing = 1.0 / (2.2 * particle_radius)
        self.p_num_x = math.floor(width * self.p_inv_spacing) + 1
        self.p_num_y = math.floor(height * self.p_inv_spacing) + 1
        self.p_num_cells = self.p_num_x * self.p_num_y

        self.num_cell_particles = np.zeros(self.p_num_cells, dtype=np.int32)
        self.first_cell_particle = np.zeros(self.p_num_cells + 1, dtype=np.int32)
        self.cell_particle_ids = np.zeros(max_particles, dtype=np.int32)

        self.num_particles = 0

        #for i in range(self.max_particles):
        #    self.particle_color[3 * i + 2] = 1.0

    def integrate_particles(self, dt, gravity):
        for i in range(self.num_particles):
            self.particle_vel[2 * i + 1] += dt * gravity
            self.particle_pos[2 * i] += self.particle_vel[2 * i] * dt
            self.particle_pos[2 * i + 1] += self.particle_vel[2 * i + 1] * dt

    def push_particles_apart(self, num_iters):
        raise NotImplementedError
        
        color_diffusion_coeff = 0.001

        self.num_cell_particles.fill(0)

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]

            xi = self.clamp(math.floor(x * self.p_inv_spacing), 0, self.p_num_x - 1)
            yi = self.clamp(math.floor(y * self.p_inv_spacing), 0, self.p_num_y - 1)
            cell_nr = xi * self.p_num_y + yi
            self.num_cell_particles[cell_nr] += 1

        first = 0
        for i in range(self.p_num_cells):
            first += self.num_cell_particles[i]
            self.first_cell_particle[i] = first
        self.first_cell_particle[self.p_num_cells] = first  # Guard

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]

            xi = self.clamp(math.floor(x * self.p_inv_spacing), 0, self.p_num_x - 1)
            yi = self.clamp(math.floor(y * self.p_inv_spacing), 0, self.p_num_y - 1)
            cell_nr = xi * self.p_num_y + yi
            self.first_cell_particle[cell_nr] -= 1
            self.cell_particle_ids[self.first_cell_particle[cell_nr]] = i

        min_dist = 2.0 * self.particle_radius
        min_dist2 = min_dist * min_dist

        for iter in range(num_iters):
            for i in range(self.num_particles):
                px = self.particle_pos[2 * i]
                py = self.particle_pos[2 * i + 1]

                pxi = math.floor(px * self.p_inv_spacing)
                pyi = math.floor(py * self.p_inv_spacing)
                x0 = max(pxi - 1, 0)
                y0 = max(pyi - 1, 0)
                x1 = min(pxi + 1, self.p_num_x - 1)
                y1 = min(pyi + 1, self.p_num_y - 1)

                for xi in range(x0, x1 + 1):
                    for yi in range(y0, y1 + 1):
                        cell_nr = xi * self.p_num_y + yi
                        first = self.first_cell_particle[cell_nr]
                        last = self.first_cell_particle[cell_nr + 1]
                        for j in range(first, last):
                            id = self.cell_particle_ids[j]
                            if id == i:
                                continue
                            qx = self.particle_pos[2 * id]
                            qy = self.particle_pos[2 * id + 1]

                            dx = qx - px
                            dy = qy - py
                            d2 = dx * dx + dy * dy
                            if d2 > min_dist2 or d2 == 0.0:
                                continue
                            d = math.sqrt(d2)
                            s = 0.5 * (min_dist - d) / d
                            dx *= s
                            dy *= s
                            self.particle_pos[2 * i] -= dx
                            self.particle_pos[2 * i + 1] -= dy
                            self.particle_pos[2 * id] += dx
                            self.particle_pos[2 * id + 1] += dy

                            for k in range(3):
                                color0 = self.particle_color[3 * i + k]
                                color1 = self.particle_color[3 * id + k]
                                color = (color0 + color1) * 0.5
                                self.particle_color[3 * i + k] = color0 + (color - color0) * color_diffusion_coeff
                                self.particle_color[3 * id + k] = color1 + (color - color1) * color_diffusion_coeff

    def handle_particle_collisions(self, obstacle_x, obstacle_y, obstacle_radius):
        raise NotImplementedError
        h = 1.0 / self.f_inv_spacing
        r = self.particle_radius
        or_ = obstacle_radius
        or2 = or_ * or_
        min_dist = obstacle_radius + r
        min_dist2 = min_dist * min_dist

        min_x = h + r
        max_x = (self.f_num_x - 1) * h - r
        min_y = h + r
        max_y = (self.f_num_y - 1) * h - r

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]

            dx = x - obstacle_x
            dy = y - obstacle_y
            d2 = dx * dx + dy * dy

            if d2 < min_dist2:
                self.particle_vel[2 * i] = 0.0
                self.particle_vel[2 * i + 1] = 0.0

            if x < min_x:
                x = min_x
                self.particle_vel[2 * i] = 0.0

            if x > max_x:
                x = max_x
                self.particle_vel[2 * i] = 0.0

            if y < min_y:
                y = min_y
                self.particle_vel[2 * i + 1] = 0.0

            if y > max_y:
                y = max_y
                self.particle_vel[2 * i + 1] = 0.0

            self.particle_pos[2 * i] = x
            self.particle_pos[2 * i + 1] = y

    def update_particle_density(self):
        n = self.f_num_y
        h = self.h
        h1 = self.f_inv_spacing
        h2 = 0.5 * h

        d = self.particle_density
        d.fill(0.0)

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]

            xi = math.floor(x * h1)
            yi = math.floor(y * h1)
            dx = x - xi * h
            dy = y - yi * h
            wi = [0.5 * (h2 - dx) * (h2 - dx), 0.75 - dx * dx, 0.5 * (h2 + dx) * (h2 + dx)]
            wj = [0.5 * (h2 - dy) * (h2 - dy), 0.75 - dy * dy, 0.5 * (h2 + dy) * (h2 + dy)]

            for m in range(3):
                for n in range(3):
                    d[(xi + m - 1) * n + (yi + n - 1)] += wi[m] * wj[n]

    def compute_particle_volumes(self):
        cell_volume = self.h * self.h
        for i in range(self.f_num_cells):
            self.particle_density[i] *= self.particle_rest_density / cell_volume

    def compute_weights(self, dt):
        h = self.h
        h1 = self.f_inv_spacing
        h2 = 0.5 * h

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]

            xi = math.floor(x * h1)
            yi = math.floor(y * h1)
            dx = x - xi * h
            dy = y - yi * h
            wi = [0.5 * (h2 - dx) * (h2 - dx), 0.75 - dx * dx, 0.5 * (h2 + dx) * (h2 + dx)]
            wj = [0.5 * (h2 - dy) * (h2 - dy), 0.75 - dy * dy, 0.5 * (h2 + dy) * (h2 + dy)]

            for m in range(3):
                for n in range(3):
                    weight = wi[m] * wj[n]
                    j = (xi + m - 1) * self.f_num_y + (yi + n - 1)
                    self.s[j] += weight * dt

    def transfer_to_grid(self, dt):
        self.u.fill(0.0)
        self.v.fill(0.0)
        self.du.fill(0.0)
        self.dv.fill(0.0)
        self.prev_u.fill(0.0)
        self.prev_v.fill(0.0)

        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]
            vx = self.particle_vel[2 * i]
            vy = self.particle_vel[2 * i + 1]

            xi = math.floor(x * self.f_inv_spacing)
            yi = math.floor(y * self.f_inv_spacing)
            dx = x - xi * self.h
            dy = y - yi * self.h

            wx = [0.5 * (0.5 - dx) * (0.5 - dx), 0.75 - dx * dx, 0.5 * (0.5 + dx) * (0.5 + dx)]
            wy = [0.5 * (0.5 - dy) * (0.5 - dy), 0.75 - dy * dy, 0.5 * (0.5 + dy) * (0.5 + dy)]

            for m in range(3):
                for n in range(3):
                    weight = wx[m] * wy[n]
                    j = (xi + m - 1) * self.f_num_y + (yi + n - 1)
                    self.u[j] += weight * vx
                    self.v[j] += weight * vy
                    self.s[j] += weight

        self.u /= self.s
        self.v /= self.s

    def project_velocity(self, dt):
        cell_volume = self.h * self.h
        self.du.fill(0.0)
        self.dv.fill(0.0)

        for i in range(1, self.f_num_x - 1):
            for j in range(1, self.f_num_y - 1):
                cell = i * self.f_num_y + j
                if self.cell_type[cell] != 1:
                    continue

                dpdx = (self.p[cell + self.f_num_y] - self.p[cell - self.f_num_y]) * 0.5 / self.h
                dpdy = (self.p[cell + 1] - self.p[cell - 1]) * 0.5 / self.h
                self.du[cell] = -dpdx * dt / cell_volume
                self.dv[cell] = -dpdy * dt / cell_volume

        self.u += self.du
        self.v += self.dv

    def apply_velocity(self, dt):
        for i in range(self.num_particles):
            x = self.particle_pos[2 * i]
            y = self.particle_pos[2 * i + 1]
            vx = self.particle_vel[2 * i]
            vy = self.particle_vel[2 * i + 1]

            xi = math.floor(x * self.f_inv_spacing)
            yi = math.floor(y * self.f_inv_spacing)
            dx = x - xi * self.h
            dy = y - yi * self.h

            wx = [0.5 * (0.5 - dx) * (0.5 - dx), 0.75 - dx * dx, 0.5 * (0.5 + dx) * (0.5 + dx)]
            wy = [0.5 * (0.5 - dy) * (0.5 - dy), 0.75 - dy * dy, 0.5 * (0.5 + dy) * (0.5 + dy)]

            for m in range(3):
                for n in range(3):
                    weight = wx[m] * wy[n]
                    j = (xi + m - 1) * self.f_num_y + (yi + n - 1)
                    vx += weight * self.u[j]
                    vy += weight * self.v[j]

            self.particle_vel[2 * i] = vx
            self.particle_vel[2 * i + 1] = vy

def main():
    pygame.init()
    width, height = 800, 600
    screen = pygame.display.set_mode((width, height))
    clock = pygame.time.Clock()
    running = True

    fluid = FlipFluid(density=1.0, width=width, height=height, spacing=10, particle_radius=2, max_particles=1000)

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        screen.fill((0, 0, 0))

        fluid.integrate_particles(dt=0.016, gravity=9.8)
        #fluid.push_particles_apart(num_iters=2)

        print(fluid.num_particles)
        for i in range(fluid.num_particles):
            x = int(fluid.particle_pos[2 * i])
            y = int(fluid.particle_pos[2 * i + 1])
            color = (
                int(fluid.particle_color[3 * i] * 255),
                int(fluid.particle_color[3 * i + 1] * 255),
                int(fluid.particle_color[3 * i + 2] * 255)
            )
            print("hola")
            pygame.draw.circle(screen, color, (x, y), fluid.particle_radius)

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    main()
